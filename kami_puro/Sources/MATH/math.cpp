//=============================================================================
//
// 汎用計算式用 [math.cpp]
// Author : 野尻　尚希
//
//=============================================================================
//*****************************************************************************
// インクルード
//*****************************************************************************
#include "../MATH/math.h"

//*****************************************************************************
// ベクトルを長さに変換
//*****************************************************************************
float MagnitudeVector(D3DXVECTOR3& v)
{
	return (float) sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
}

//*****************************************************************************
// ベクトルを長さの二乗に変換
//*****************************************************************************
float PowVector(D3DXVECTOR3& v)
{
	return (float) (v.x*v.x + v.y*v.y + v.z*v.z);
}

//*****************************************************************************
// 角度正規関数関数
//*****************************************************************************
void NormalizeRotation(float *rot)
{
	if(*rot < -D3DX_PI)
	{
		*rot += D3DX_PI * 2.f;	// 360度をにしたいため2倍している
	}
	if(*rot > D3DX_PI)
	{
		*rot -= D3DX_PI * 2.f;	// 360度をにしたいため2倍している
	}
}
void NormalizeRotation(D3DXVECTOR3 *rot)
{
	if(rot->x < -D3DX_PI)
	{
		rot->x += D3DX_PI * 2.f;	// 360度をにしたいため2倍している
	}
	if(rot->x > D3DX_PI)
	{
		rot->x -= D3DX_PI * 2.f;	// 360度をにしたいため2倍している
	}

	if(rot->y < -D3DX_PI)
	{
		rot->y += D3DX_PI * 2.f;	// 360度をにしたいため2倍している
	}
	if(rot->y > D3DX_PI)
	{
		rot->y -= D3DX_PI * 2.f;	// 360度をにしたいため2倍している
	}

	if(rot->z < -D3DX_PI)
	{
		rot->z += D3DX_PI * 2.f;	// 360度をにしたいため2倍している
	}
	if(rot->z > D3DX_PI)
	{
		rot->z -= D3DX_PI * 2.f;	// 360度をにしたいため2倍している
	}
}

//==========================================================
// イージング補間補間   3次関数
//==========================================================
float EasingInterpolation(float start, float end, float time)
{
	assert(time >= 0.f && time <= 1.f && "timeは0〜1の間！");

	float ans = 0.f;
	float middlePoint = (end - start) * 0.5f;

	if (time < 0.5f)
	{
		ans = start + middlePoint * pow(2.f * time, 3);
	}
	else
	{
		ans = end + middlePoint * pow(2.f * time - 2.f, 3);
	}
	return ans;
}
//----EOF----